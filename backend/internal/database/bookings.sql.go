// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: bookings.sql

package database

import (
	"context"
	"time"
)

const createBooking = `-- name: CreateBooking :one
INSERT INTO bookings (tour_id, created_at, updated_at, date)
  VALUES (
  $1,
  NOW(),
  NOW(),
  $2
  )
RETURNING id, tour_id, created_at, updated_at, date
`

type CreateBookingParams struct {
	TourID int32
	Date   time.Time
}

func (q *Queries) CreateBooking(ctx context.Context, arg CreateBookingParams) (Booking, error) {
	row := q.db.QueryRowContext(ctx, createBooking, arg.TourID, arg.Date)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.TourID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Date,
	)
	return i, err
}

const getAllBookingsOnDate = `-- name: GetAllBookingsOnDate :many
SELECT
  b.id AS booking_id,
  t.name AS tour_name,
  b.date,
  COUNT(g.id) AS group_count,
  COALESCE(SUM(g.pax), 0) AS total_pax,
  COALESCE(STRING_AGG(g.email, ', '), '') AS attending_groups
FROM bookings b
JOIN tours t ON b.tour_id = t.id
LEFT JOIN groups g ON g.booking_id = b.id
WHERE date = $1 AND NOT status = 'pending'
GROUP BY b.id, t.name, b.date
ORDER BY b.date DESC
`

type GetAllBookingsOnDateRow struct {
	BookingID       int32
	TourName        string
	Date            time.Time
	GroupCount      int64
	TotalPax        interface{}
	AttendingGroups interface{}
}

func (q *Queries) GetAllBookingsOnDate(ctx context.Context, date time.Time) ([]GetAllBookingsOnDateRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllBookingsOnDate, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllBookingsOnDateRow
	for rows.Next() {
		var i GetAllBookingsOnDateRow
		if err := rows.Scan(
			&i.BookingID,
			&i.TourName,
			&i.Date,
			&i.GroupCount,
			&i.TotalPax,
			&i.AttendingGroups,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookingByTourDate = `-- name: GetBookingByTourDate :one
SELECT id, tour_id, created_at, updated_at, date FROM bookings
WHERE date = $1 AND tour_id = $2
`

type GetBookingByTourDateParams struct {
	Date   time.Time
	TourID int32
}

func (q *Queries) GetBookingByTourDate(ctx context.Context, arg GetBookingByTourDateParams) (Booking, error) {
	row := q.db.QueryRowContext(ctx, getBookingByTourDate, arg.Date, arg.TourID)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.TourID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Date,
	)
	return i, err
}

const getBookings = `-- name: GetBookings :many
SELECT
  b.id AS booking_id,
  t.name AS tour_name,
  b.date,
  COUNT(g.id) AS group_count,
  COALESCE(SUM(g.pax), 0) AS total_pax,
  COALESCE(STRING_AGG(g.email, ', '), '') AS attending_groups
FROM bookings b
JOIN tours t ON b.tour_id = t.id
LEFT JOIN groups g ON g.booking_id = b.id
GROUP BY b.id, t.name, b.date
ORDER BY b.date DESC
`

type GetBookingsRow struct {
	BookingID       int32
	TourName        string
	Date            time.Time
	GroupCount      int64
	TotalPax        interface{}
	AttendingGroups interface{}
}

func (q *Queries) GetBookings(ctx context.Context) ([]GetBookingsRow, error) {
	rows, err := q.db.QueryContext(ctx, getBookings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBookingsRow
	for rows.Next() {
		var i GetBookingsRow
		if err := rows.Scan(
			&i.BookingID,
			&i.TourName,
			&i.Date,
			&i.GroupCount,
			&i.TotalPax,
			&i.AttendingGroups,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
